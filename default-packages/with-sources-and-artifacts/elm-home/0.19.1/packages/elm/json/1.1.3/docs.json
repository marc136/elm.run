[{"name":"Json.Decode","comment":" Turn JSON values into Elm values. Definitely check out this [intro to\nJSON decoders][guide] to get a feel for how this library works!\n\n[guide]: https://guide.elm-lang.org/effects/json.html\n\n# Primitives\n@docs Decoder, string, bool, int, float\n\n# Data Structures\n@docs nullable, list, array, dict, keyValuePairs, oneOrMore\n\n# Object Primitives\n@docs field, at, index\n\n# Inconsistent Structure\n@docs maybe, oneOf\n\n# Run Decoders\n@docs decodeString, decodeValue, Value, Error, errorToString\n\n# Mapping\n\n**Note:** If you run out of map functions, take a look at [elm-json-decode-pipeline][pipe]\nwhich makes it easier to handle large objects, but produces lower quality type\nerrors.\n\n[pipe]: /packages/NoRedInk/elm-json-decode-pipeline/latest\n\n@docs map, map2, map3, map4, map5, map6, map7, map8\n\n# Fancy Decoding\n@docs lazy, value, null, succeed, fail, andThen\n","unions":[{"name":"Decoder","comment":" A value that knows how to decode JSON values.\n\nThere is a whole section in `guide.elm-lang.org` about decoders, so [check it\nout](https://guide.elm-lang.org/interop/json.html) for a more comprehensive\nintroduction!\n","args":["a"],"cases":[]},{"name":"Error","comment":" A structured error describing exactly how the decoder failed. You can use\nthis to create more elaborate visualizations of a decoder problem. For example,\nyou could show the entire JSON object and show the part causing the failure in\nred.\n","args":[],"cases":[["Field",["String.String","Json.Decode.Error"]],["Index",["Basics.Int","Json.Decode.Error"]],["OneOf",["List.List Json.Decode.Error"]],["Failure",["String.String","Json.Decode.Value"]]]}],"aliases":[{"name":"Value","comment":" Represents a JavaScript value.\n","args":[],"type":"Json.Encode.Value"}],"values":[{"name":"andThen","comment":" Create decoders that depend on previous results. If you are creating\nversioned data, you might do something like this:\n\n    info : Decoder Info\n    info =\n      field \"version\" int\n        |> andThen infoHelp\n\n    infoHelp : Int -> Decoder Info\n    infoHelp version =\n      case version of\n        4 ->\n          infoDecoder4\n\n        3 ->\n          infoDecoder3\n\n        _ ->\n          fail <|\n            \"Trying to decode info, but version \"\n            ++ toString version ++ \" is not supported.\"\n\n    -- infoDecoder4 : Decoder Info\n    -- infoDecoder3 : Decoder Info\n","type":"(a -> Json.Decode.Decoder b) -> Json.Decode.Decoder a -> Json.Decode.Decoder b"},{"name":"array","comment":" Decode a JSON array into an Elm `Array`.\n\n    decodeString (array int) \"[1,2,3]\"       == Ok (Array.fromList [1,2,3])\n    decodeString (array bool) \"[true,false]\" == Ok (Array.fromList [True,False])\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder (Array.Array a)"},{"name":"at","comment":" Decode a nested JSON object, requiring certain fields.\n\n    json = \"\"\"{ \"person\": { \"name\": \"tom\", \"age\": 42 } }\"\"\"\n\n    decodeString (at [\"person\", \"name\"] string) json  == Ok \"tom\"\n    decodeString (at [\"person\", \"age\" ] int   ) json  == Ok \"42\n\nThis is really just a shorthand for saying things like:\n\n    field \"person\" (field \"name\" string) == at [\"person\",\"name\"] string\n","type":"List.List String.String -> Json.Decode.Decoder a -> Json.Decode.Decoder a"},{"name":"bool","comment":" Decode a JSON boolean into an Elm `Bool`.\n\n    decodeString bool \"true\"              == Ok True\n    decodeString bool \"42\"                == Err ...\n    decodeString bool \"3.14\"              == Err ...\n    decodeString bool \"\\\"hello\\\"\"         == Err ...\n    decodeString bool \"{ \\\"hello\\\": 42 }\" == Err ...\n","type":"Json.Decode.Decoder Basics.Bool"},{"name":"decodeString","comment":" Parse the given string into a JSON value and then run the `Decoder` on it.\nThis will fail if the string is not well-formed JSON or if the `Decoder`\nfails for some reason.\n\n    decodeString int \"4\"     == Ok 4\n    decodeString int \"1 + 2\" == Err ...\n","type":"Json.Decode.Decoder a -> String.String -> Result.Result Json.Decode.Error a"},{"name":"decodeValue","comment":" Run a `Decoder` on some JSON `Value`. You can send these JSON values\nthrough ports, so that is probably the main time you would use this function.\n","type":"Json.Decode.Decoder a -> Json.Decode.Value -> Result.Result Json.Decode.Error a"},{"name":"dict","comment":" Decode a JSON object into an Elm `Dict`.\n\n    decodeString (dict int) \"{ \\\"alice\\\": 42, \\\"bob\\\": 99 }\"\n      == Ok (Dict.fromList [(\"alice\", 42), (\"bob\", 99)])\n\nIf you need the keys (like `\"alice\"` and `\"bob\"`) available in the `Dict`\nvalues as well, I recommend using a (private) intermediate data structure like\n`Info` in this example:\n\n    module User exposing (User, decoder)\n\n    import Dict\n    import Json.Decode exposing (..)\n\n    type alias User =\n      { name : String\n      , height : Float\n      , age : Int\n      }\n\n    decoder : Decoder (Dict.Dict String User)\n    decoder =\n      map (Dict.map infoToUser) (dict infoDecoder)\n\n    type alias Info =\n      { height : Float\n      , age : Int\n      }\n\n    infoDecoder : Decoder Info\n    infoDecoder =\n      map2 Info\n        (field \"height\" float)\n        (field \"age\" int)\n\n    infoToUser : String -> Info -> User\n    infoToUser name { height, age } =\n      User name height age\n\nSo now JSON like `{ \"alice\": { height: 1.6, age: 33 }}` are turned into\ndictionary values like `Dict.singleton \"alice\" (User \"alice\" 1.6 33)` if\nyou need that.\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder (Dict.Dict String.String a)"},{"name":"errorToString","comment":" Convert a decoding error into a `String` that is nice for debugging.\n\nIt produces multiple lines of output, so you may want to peek at it with\nsomething like this:\n\n    import Html\n    import Json.Decode as Decode\n\n    errorToHtml : Decode.Error -> Html.Html msg\n    errorToHtml error =\n      Html.pre [] [ Html.text (Decode.errorToString error) ]\n\n**Note:** It would be cool to do nicer coloring and fancier HTML, but I wanted\nto avoid having an `elm/html` dependency for now. It is totally possible to\ncrawl the `Error` structure and create this separately though!\n","type":"Json.Decode.Error -> String.String"},{"name":"fail","comment":" Ignore the JSON and make the decoder fail. This is handy when used with\n`oneOf` or `andThen` where you want to give a custom error message in some\ncase.\n\nSee the [`andThen`](#andThen) docs for an example.\n","type":"String.String -> Json.Decode.Decoder a"},{"name":"field","comment":" Decode a JSON object, requiring a particular field.\n\n    decodeString (field \"x\" int) \"{ \\\"x\\\": 3 }\"            == Ok 3\n    decodeString (field \"x\" int) \"{ \\\"x\\\": 3, \\\"y\\\": 4 }\"  == Ok 3\n    decodeString (field \"x\" int) \"{ \\\"x\\\": true }\"         == Err ...\n    decodeString (field \"x\" int) \"{ \\\"y\\\": 4 }\"            == Err ...\n\n    decodeString (field \"name\" string) \"{ \\\"name\\\": \\\"tom\\\" }\" == Ok \"tom\"\n\nThe object *can* have other fields. Lots of them! The only thing this decoder\ncares about is if `x` is present and that the value there is an `Int`.\n\nCheck out [`map2`](#map2) to see how to decode multiple fields!\n","type":"String.String -> Json.Decode.Decoder a -> Json.Decode.Decoder a"},{"name":"float","comment":" Decode a JSON number into an Elm `Float`.\n\n    decodeString float \"true\"              == Err ..\n    decodeString float \"42\"                == Ok 42\n    decodeString float \"3.14\"              == Ok 3.14\n    decodeString float \"\\\"hello\\\"\"         == Err ...\n    decodeString float \"{ \\\"hello\\\": 42 }\" == Err ...\n","type":"Json.Decode.Decoder Basics.Float"},{"name":"index","comment":" Decode a JSON array, requiring a particular index.\n\n    json = \"\"\"[ \"alice\", \"bob\", \"chuck\" ]\"\"\"\n\n    decodeString (index 0 string) json  == Ok \"alice\"\n    decodeString (index 1 string) json  == Ok \"bob\"\n    decodeString (index 2 string) json  == Ok \"chuck\"\n    decodeString (index 3 string) json  == Err ...\n","type":"Basics.Int -> Json.Decode.Decoder a -> Json.Decode.Decoder a"},{"name":"int","comment":" Decode a JSON number into an Elm `Int`.\n\n    decodeString int \"true\"              == Err ...\n    decodeString int \"42\"                == Ok 42\n    decodeString int \"3.14\"              == Err ...\n    decodeString int \"\\\"hello\\\"\"         == Err ...\n    decodeString int \"{ \\\"hello\\\": 42 }\" == Err ...\n","type":"Json.Decode.Decoder Basics.Int"},{"name":"keyValuePairs","comment":" Decode a JSON object into an Elm `List` of pairs.\n\n    decodeString (keyValuePairs int) \"{ \\\"alice\\\": 42, \\\"bob\\\": 99 }\"\n      == Ok [(\"alice\", 42), (\"bob\", 99)]\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder (List.List ( String.String, a ))"},{"name":"lazy","comment":" Sometimes you have JSON with recursive structure, like nested comments.\nYou can use `lazy` to make sure your decoder unrolls lazily.\n\n    type alias Comment =\n      { message : String\n      , responses : Responses\n      }\n\n    type Responses = Responses (List Comment)\n\n    comment : Decoder Comment\n    comment =\n      map2 Comment\n        (field \"message\" string)\n        (field \"responses\" (map Responses (list (lazy (\\_ -> comment)))))\n\nIf we had said `list comment` instead, we would start expanding the value\ninfinitely. What is a `comment`? It is a decoder for objects where the\n`responses` field contains comments. What is a `comment` though? Etc.\n\nBy using `list (lazy (\\_ -> comment))` we make sure the decoder only expands\nto be as deep as the JSON we are given. You can read more about recursive data\nstructures [here][].\n\n[here]: https://github.com/elm/compiler/blob/master/hints/recursive-alias.md\n","type":"(() -> Json.Decode.Decoder a) -> Json.Decode.Decoder a"},{"name":"list","comment":" Decode a JSON array into an Elm `List`.\n\n    decodeString (list int) \"[1,2,3]\"       == Ok [1,2,3]\n    decodeString (list bool) \"[true,false]\" == Ok [True,False]\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder (List.List a)"},{"name":"map","comment":" Transform a decoder. Maybe you just want to know the length of a string:\n\n    import String\n\n    stringLength : Decoder Int\n    stringLength =\n      map String.length string\n\nIt is often helpful to use `map` with `oneOf`, like when defining `nullable`:\n\n    nullable : Decoder a -> Decoder (Maybe a)\n    nullable decoder =\n      oneOf\n        [ null Nothing\n        , map Just decoder\n        ]\n","type":"(a -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder value"},{"name":"map2","comment":" Try two decoders and then combine the result. We can use this to decode\nobjects with many fields:\n\n    type alias Point = { x : Float, y : Float }\n\n    point : Decoder Point\n    point =\n      map2 Point\n        (field \"x\" float)\n        (field \"y\" float)\n\n    -- decodeString point \"\"\"{ \"x\": 3, \"y\": 4 }\"\"\" == Ok { x = 3, y = 4 }\n\nIt tries each individual decoder and puts the result together with the `Point`\nconstructor.\n","type":"(a -> b -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder value"},{"name":"map3","comment":" Try three decoders and then combine the result. We can use this to decode\nobjects with many fields:\n\n    type alias Person = { name : String, age : Int, height : Float }\n\n    person : Decoder Person\n    person =\n      map3 Person\n        (at [\"name\"] string)\n        (at [\"info\",\"age\"] int)\n        (at [\"info\",\"height\"] float)\n\n    -- json = \"\"\"{ \"name\": \"tom\", \"info\": { \"age\": 42, \"height\": 1.8 } }\"\"\"\n    -- decodeString person json == Ok { name = \"tom\", age = 42, height = 1.8 }\n\nLike `map2` it tries each decoder in order and then give the results to the\n`Person` constructor. That can be any function though!\n","type":"(a -> b -> c -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder value"},{"name":"map4","comment":"","type":"(a -> b -> c -> d -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder value"},{"name":"map5","comment":"","type":"(a -> b -> c -> d -> e -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder value"},{"name":"map6","comment":"","type":"(a -> b -> c -> d -> e -> f -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder value"},{"name":"map7","comment":"","type":"(a -> b -> c -> d -> e -> f -> g -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder value"},{"name":"map8","comment":"","type":"(a -> b -> c -> d -> e -> f -> g -> h -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder h -> Json.Decode.Decoder value"},{"name":"maybe","comment":" Helpful for dealing with optional fields. Here are a few slightly different\nexamples:\n\n    json = \"\"\"{ \"name\": \"tom\", \"age\": 42 }\"\"\"\n\n    decodeString (maybe (field \"age\"    int  )) json == Ok (Just 42)\n    decodeString (maybe (field \"name\"   int  )) json == Ok Nothing\n    decodeString (maybe (field \"height\" float)) json == Ok Nothing\n\n    decodeString (field \"age\"    (maybe int  )) json == Ok (Just 42)\n    decodeString (field \"name\"   (maybe int  )) json == Ok Nothing\n    decodeString (field \"height\" (maybe float)) json == Err ...\n\nNotice the last example! It is saying we *must* have a field named `height` and\nthe content *may* be a float. There is no `height` field, so the decoder fails.\n\nPoint is, `maybe` will make exactly what it contains conditional. For optional\nfields, this means you probably want it *outside* a use of `field` or `at`.\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe.Maybe a)"},{"name":"null","comment":" Decode a `null` value into some Elm value.\n\n    decodeString (null False) \"null\" == Ok False\n    decodeString (null 42) \"null\"    == Ok 42\n    decodeString (null 42) \"42\"      == Err ..\n    decodeString (null 42) \"false\"   == Err ..\n\nSo if you ever see a `null`, this will return whatever value you specified.\n","type":"a -> Json.Decode.Decoder a"},{"name":"nullable","comment":" Decode a nullable JSON value into an Elm value.\n\n    decodeString (nullable int) \"13\"    == Ok (Just 13)\n    decodeString (nullable int) \"42\"    == Ok (Just 42)\n    decodeString (nullable int) \"null\"  == Ok Nothing\n    decodeString (nullable int) \"true\"  == Err ..\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe.Maybe a)"},{"name":"oneOf","comment":" Try a bunch of different decoders. This can be useful if the JSON may come\nin a couple different formats. For example, say you want to read an array of\nnumbers, but some of them are `null`.\n\n    import String\n\n    badInt : Decoder Int\n    badInt =\n      oneOf [ int, null 0 ]\n\n    -- decodeString (list badInt) \"[1,2,null,4]\" == Ok [1,2,0,4]\n\nWhy would someone generate JSON like this? Questions like this are not good\nfor your health. The point is that you can use `oneOf` to handle situations\nlike this!\n\nYou could also use `oneOf` to help version your data. Try the latest format,\nthen a few older ones that you still support. You could use `andThen` to be\neven more particular if you wanted.\n","type":"List.List (Json.Decode.Decoder a) -> Json.Decode.Decoder a"},{"name":"oneOrMore","comment":" Decode a JSON array that has one or more elements. This comes up if you\nwant to enable drag-and-drop of files into your application. You would pair\nthis function with [`elm/file`]() to write a `dropDecoder` like this:\n\n    import File exposing (File)\n    import Json.Decoder as D\n\n    type Msg\n      = GotFiles File (List Files)\n\n    inputDecoder : D.Decoder Msg\n    inputDecoder =\n      D.at [\"dataTransfer\",\"files\"] (D.oneOrMore GotFiles File.decoder)\n\nThis captures the fact that you can never drag-and-drop zero files.\n","type":"(a -> List.List a -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder value"},{"name":"string","comment":" Decode a JSON string into an Elm `String`.\n\n    decodeString string \"true\"              == Err ...\n    decodeString string \"42\"                == Err ...\n    decodeString string \"3.14\"              == Err ...\n    decodeString string \"\\\"hello\\\"\"         == Ok \"hello\"\n    decodeString string \"{ \\\"hello\\\": 42 }\" == Err ...\n","type":"Json.Decode.Decoder String.String"},{"name":"succeed","comment":" Ignore the JSON and produce a certain Elm value.\n\n    decodeString (succeed 42) \"true\"    == Ok 42\n    decodeString (succeed 42) \"[1,2,3]\" == Ok 42\n    decodeString (succeed 42) \"hello\"   == Err ... -- this is not a valid JSON string\n\nThis is handy when used with `oneOf` or `andThen`.\n","type":"a -> Json.Decode.Decoder a"},{"name":"value","comment":" Do not do anything with a JSON value, just bring it into Elm as a `Value`.\nThis can be useful if you have particularly complex data that you would like to\ndeal with later. Or if you are going to send it out a port and do not care\nabout its structure.\n","type":"Json.Decode.Decoder Json.Decode.Value"}],"binops":[]},{"name":"Json.Encode","comment":" Library for turning Elm values into Json values.\n\n# Encoding\n@docs encode, Value\n\n# Primitives\n@docs string, int, float, bool, null\n\n# Arrays\n@docs list, array, set\n\n# Objects\n@docs object, dict\n","unions":[{"name":"Value","comment":" Represents a JavaScript value.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"array","comment":" Turn an `Array` into a JSON array.\n","type":"(a -> Json.Encode.Value) -> Array.Array a -> Json.Encode.Value"},{"name":"bool","comment":" Turn a `Bool` into a JSON boolean.\n\n    import Json.Encode exposing (encode, bool)\n\n    -- encode 0 (bool True)  == \"true\"\n    -- encode 0 (bool False) == \"false\"\n","type":"Basics.Bool -> Json.Encode.Value"},{"name":"dict","comment":" Turn a `Dict` into a JSON object.\n\n    import Dict exposing (Dict)\n    import Json.Encode as Encode\n\n    people : Dict String Int\n    people =\n      Dict.fromList [ (\"Tom\",42), (\"Sue\", 38) ]\n\n    -- Encode.encode 0 (Encode.dict identity Encode.int people)\n    --   == \"\"\"{\"Tom\":42,\"Sue\":38}\"\"\"\n","type":"(k -> String.String) -> (v -> Json.Encode.Value) -> Dict.Dict k v -> Json.Encode.Value"},{"name":"encode","comment":" Convert a `Value` into a prettified string. The first argument specifies\nthe amount of indentation in the resulting string.\n\n    import Json.Encode as Encode\n\n    tom : Encode.Value\n    tom =\n        Encode.object\n            [ ( \"name\", Encode.string \"Tom\" )\n            , ( \"age\", Encode.int 42 )\n            ]\n\n    compact = Encode.encode 0 tom\n    -- {\"name\":\"Tom\",\"age\":42}\n\n    readable = Encode.encode 4 tom\n    -- {\n    --     \"name\": \"Tom\",\n    --     \"age\": 42\n    -- }\n","type":"Basics.Int -> Json.Encode.Value -> String.String"},{"name":"float","comment":" Turn a `Float` into a JSON number.\n\n    import Json.Encode exposing (encode, float)\n\n    -- encode 0 (float 3.14)     == \"3.14\"\n    -- encode 0 (float 1.618)    == \"1.618\"\n    -- encode 0 (float -42)      == \"-42\"\n    -- encode 0 (float NaN)      == \"null\"\n    -- encode 0 (float Infinity) == \"null\"\n\n**Note:** Floating point numbers are defined in the [IEEE 754 standard][ieee]\nwhich is hardcoded into almost all CPUs. This standard allows `Infinity` and\n`NaN`. [The JSON spec][json] does not include these values, so we encode them\nboth as `null`.\n\n[ieee]: https://en.wikipedia.org/wiki/IEEE_754\n[json]: https://www.json.org/\n","type":"Basics.Float -> Json.Encode.Value"},{"name":"int","comment":" Turn an `Int` into a JSON number.\n\n    import Json.Encode exposing (encode, int)\n\n    -- encode 0 (int 42) == \"42\"\n    -- encode 0 (int -7) == \"-7\"\n    -- encode 0 (int 0)  == \"0\"\n","type":"Basics.Int -> Json.Encode.Value"},{"name":"list","comment":" Turn a `List` into a JSON array.\n\n    import Json.Encode as Encode exposing (bool, encode, int, list, string)\n\n    -- encode 0 (list int [1,3,4])       == \"[1,3,4]\"\n    -- encode 0 (list bool [True,False]) == \"[true,false]\"\n    -- encode 0 (list string [\"a\",\"b\"])  == \"\"\"[\"a\",\"b\"]\"\"\"\n\n","type":"(a -> Json.Encode.Value) -> List.List a -> Json.Encode.Value"},{"name":"null","comment":" Create a JSON `null` value.\n\n    import Json.Encode exposing (encode, null)\n\n    -- encode 0 null == \"null\"\n","type":"Json.Encode.Value"},{"name":"object","comment":" Create a JSON object.\n\n    import Json.Encode as Encode\n\n    tom : Encode.Value\n    tom =\n        Encode.object\n            [ ( \"name\", Encode.string \"Tom\" )\n            , ( \"age\", Encode.int 42 )\n            ]\n\n    -- Encode.encode 0 tom == \"\"\"{\"name\":\"Tom\",\"age\":42}\"\"\"\n","type":"List.List ( String.String, Json.Encode.Value ) -> Json.Encode.Value"},{"name":"set","comment":" Turn an `Set` into a JSON array.\n","type":"(a -> Json.Encode.Value) -> Set.Set a -> Json.Encode.Value"},{"name":"string","comment":" Turn a `String` into a JSON string.\n\n    import Json.Encode exposing (encode, string)\n\n    -- encode 0 (string \"\")      == \"\\\"\\\"\"\n    -- encode 0 (string \"abc\")   == \"\\\"abc\\\"\"\n    -- encode 0 (string \"hello\") == \"\\\"hello\\\"\"\n","type":"String.String -> Json.Encode.Value"}],"binops":[]}]